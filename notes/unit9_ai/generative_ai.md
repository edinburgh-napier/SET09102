---
title: Generative AI
parent: AI in Software Engineering
has_children: true
has_toc: false
nav_order: 3
---

# Generative AI


## Software assistants

AI code completion and code generation tools have become essential for boosting productivity and 
improving code quality in software development. Here’s a list of popular tools that are widely used 
in the industry:

### AI Code Completion Tools

* GitHub Copilot - Developed by GitHub and powered by OpenAI Codex, it suggests whole lines or 
  blocks of code as you type, learning from the context within your existing code.
* Tabnine - An AI-powered code completion tool that supports multiple programming languages and 
  integrates with various IDEs.
* Kite - Uses machine learning to provide code completions for Python, JavaScript, and other popular 
  languages, working alongside popular IDEs like VS Code, Atom, and Sublime Text.
* IntelliCode - Microsoft’s IntelliCode enhances the capabilities of Visual Studio by providing 
  AI-assisted code completions based on thousands of open source projects on GitHub.
* Codota - Offers code completions for Java and other languages by learning from millions of programs.

### AI Code Generation Tools

* OpenAI Codex - A powerful model trained on a broad range of programming languages and contexts, 
  capable of generating code snippets and even entire applications from natural language descriptions.
* DeepCode - This tool uses AI to analyze your code and suggest improvements, such as refactoring and 
  bug fixes.
* SourceAI - A tool that generates code from a plain English input, supporting various programming 
  languages and frameworks.
* Ponicode - Focuses on generating unit tests automatically, but also assists in code generation and 
  documentation within an IDE.
* AI21 Studio’s Jurassic-1 - While primarily known for its capabilities in natural language 
  processing, it also offers potential in generating code based on textual descriptions.

These tools are designed to assist developers in different stages of the coding process, from 
writing more efficient code to generating boilerplate code and even entire modules, thereby reducing 
development time and improving code quality.


Most IDEs include a code completion facility that offers suggestions for how to finish
the token or line that you are currently typing out. There are two main sources of
information for these hints. The first is the syntax of the language you are working
with - its keywords and general structural rules allow the editor to guess what you
intend. The second source of information is the structure of the code that you have
already written, or which comes from a package that you have imported. Either way,
the internal structure of the classes defined in existing code can be introspected
by the editor to show what options exist in the current context. Fig.1 shows the
suggestions provided by Visual Studio in response to the user typing the dot after
an object name. Microsoft coined the term *Intellisense* to describe the various
coding and structural hints provided by their tools. The term has now been adopted
in other environments as well.

![Intellisense suggestions](../../images/intellisense.png)

*Fig. 1: Context-sensitive suggestions generated from introspection in Visual Studio*

With the advent of LLMs, code completion suggestions have taken a huge leap forwards.
[GitHub Copilot](https://docs.github.com/en/copilot/quickstart) for example has been
trained on all the code in GitHub repositories. It therefore has access to patterns
that have been generalised based on many thousands of examples. This allows it to
predict the structure of entire classes or methods rather than just the next symbol.
It also uses the code written so far in the file in the same way as a prompt. Its
suggestions are therefore tailored to the specific context and contain correctly-named
variables, classes, interfaces, etc. Copilot suggestions are presented in exactly the
same way as Intellisense hints - they are just longer. In this way, AI assistants
like Copilot are simply extensions of exisiting functionality.

## Conclusions and recommendations

The practical value of generative AI in accelerating software development cannot be
ignored. A lot of routine software development will be eliminated by simply mining
software repositories such as GitHub. The successful software engineer will need a
good understanding of AI tools and their limitations and will also need to keep pace
with future developments.

For the software engineering student there is a further challenge related to academic
integrity. Many subject areas are worried that students will submit work that has been
generated by AI rather than by the students themselves. For those disciplines that is
a major problem. In software engineering, however, learning to use generative AI
effectively will quickly become essential. The key question is how the student has
used the generated material. It is unlikely that generated code will offer a good
solution to problems of any complexity. The skill will be in the adaptations and
customisations that the student then makes to better fit the solution to the
requirements. This process needs to be as transparent as possible so that the student's
level of skill is clear. The following recommendations should help to do that and to
avoid any accusations of academic misconduct.

1. When AI tools have been used, this must be stated at the outset.
2. The software development process should be clearly described, detailing the
   additional work that has gone into the project on top of the generated code. This
   could be presented with the help of a flow diagram like the one in Fig. 2.
3. The original generated code should be available for inspection and comparison with the
   final version.
4. Provide a justified rationale for the modifications made to the generated code based
   on the requirements of the project and the quality of the final product.
5. If possible, a theoretically justified process should be adopted for the use of
   AI code generation as part of the development methodology. At the time of writing,
   no formalised methods exist, and individual actions will need to be justified on
   their own merits. It will not be long, however, before project methodologies catch
   up with technological developments.

![Generative development process](../../images/generative_development.png)

*Fig. 2. An outline generative development process*

The final word goes to two German researchers, authors of a paper entitled, *How ChatGPT
Will Change Software Engineering Education*:

> It is crucial to acknowledge that although AI-generated code can serve as a valuable
> resource for developers, it cannot replace human expertise and comprehension. The
> developer will still need to understand the problem and the requirements and validate
> the code generated. They will also need to maintain, debug and adapt the code to
> changing requirements. Thus, future engineers will need to prioritise software design
> competencies over manual code writing skills.
>
> As AI-generated code becomes more
> prevalent, software engineers will need to have a deeper understanding of how to
> design and architect a software system. This includes understanding howto properly
> define the problem and requirements, as well as how to validate and test the
> AI-generated code to ensure it meets the needs of the project. Engineers will also
> need to have a good understanding of how AI algorithms like ChatGPT work, in order to
> be able to adjust or fine-tune the generated code as needed.
>
> [Daun & Brings, 2023](https://doi.org/10.1145/3587102.3588815)

## Further reading

* The Next Frontier in Software Development: AI-Augmented Software Development Processes [(Ozkaya, 2023)](https://doi.org/10.1109/MS.2023.3278056)
* A Review of ChatGPT Applications in Education, Marketing, Software Engineering, and Healthcare: Benefits, Drawbacks, and Research Directions [(Fraiwan & Khasawneh, 2023)](https://doi.org/10.48550/arXiv.2305.00237)
